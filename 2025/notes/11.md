# Advent of Code 2025 Day 11

## Part A

This one was cool. Using dynamic programming, `paths` contains all the ways we can get from the start (`you`) to that particular node. Then I traveled to a node only if we visited all of its parents. In this case, I had to remove the parents that I could not get to from `you`. (Below is the updated code using the `get_descendants()` method I wrote for Part B)

## Part B

This one was very difficult.

At first, I tried to do something similar, defining my states to be `(node, fft_flag, dac_flag)`, where `fft_flag` would be if I reached `fft` and `dac_flag` the same for `dac`.

For some reason, I couldn't figure out why it wasn't fully working.

I then decided to [visualize](11_graph.png) my input, where I realized that you always have to reach `fft` before `dac` (in my input).

Therefore, the code was modified to be as follows:
1. Count the number of paths from `svr` to `fft`.
2. Count the number of paths from `fft` to `dac`.
3. Count the number of paths from `dac` to `end`.
4. Multiply these numbers.

What I actually did was reset my `path` dictionary when I finished a step, then prune the `parents` to only had descendants of the next root, then initialize the root's count to the previous number.

## Code

```python
from aocd.models import Puzzle
from collections import defaultdict

puzzle = Puzzle(year = 2025, day = 11)

data = puzzle.input_data
# data = puzzle.examples[0].input_data


def part_a():

    descendants = dict()
    def get_descendants(key:str):
        if key in descendants:
            return descendants[key]
        D = children[key].copy()
        for child in children[key]:
            D.update(get_descendants(child))
        descendants[key] = D
        return D
    


    lines = data.split('\n')
    parents = dict()
    children = defaultdict(set)

    for line in lines:
        names = line.split(' ')
        source = names[0][:-1]
        targets = set(names[1:])
        children[source] = targets
        for target in targets:
            if target not in parents:
                parents[target] = set()
            parents[target].add(source)

    valid_keys = get_descendants("you")
    valid_keys.add("you")
    for key in valid_keys:
        children[key].intersection_update(valid_keys)
        if key in parents:
            parents[key].intersection_update(valid_keys)

    paths = defaultdict(int)
    to_visit = set()
    to_visit.add('you')
    paths['you'] = 1
    visited = set()

    while 'out' not in visited:
        curr = to_visit.pop()
        if curr in visited:
            continue
        visited.add(curr)
        for child in children[curr]:
            paths[child] += paths[curr]
            if child not in visited and parents[child] <= visited:
                to_visit.add(child)
    print(paths['out'])
    puzzle.answer_a = paths['out']


def part_b():
    lines = data.split('\n')
    parents:dict[str,set[str]] = dict()
    children = defaultdict(set)
    
    allNames = set()

    for line in lines:
        names = line.split(' ')
        source = names[0][:-1]
        allNames.add(source)
        targets = set(names[1:])
        children[source] = targets
        for target in targets:
            if target not in parents:
                parents[target] = set()
            allNames.add(target)
            parents[target].add(source)

    

    start = True
    to_remove = set()
    while start or len(to_remove) > 0:
        start = False
        to_remove = set()
        for parent in allNames:
            if parent != 'svr' and (parent not in parents or len(parents[parent]) == 0):
                to_remove.add(parent)
                if parent in parents:
                    parents.pop(parent)
                
        allNames.difference_update(to_remove)
        for parent in parents:
            parents[parent].difference_update(to_remove)

    
    
    to_visit = set()
    to_visit.add('svr')
    paths = defaultdict(int)
    paths['svr'] = 1
    visited = set()

    while 'fft' not in visited:
        curr = to_visit.pop()
        if curr in visited:
            continue
        visited.add(curr)
        for child in children[curr]:
            paths[child] += paths[curr]
            if child not in visited and parents[child] <= visited:
                to_visit.add(child)
    
    descendants = dict()
    def get_descendants(key:str):
        if key in descendants:
            return descendants[key]
        D = children[key].copy()
        for child in children[key]:
            D.update(get_descendants(child))
        descendants[key] = D
        return D
    
    valid_keys = get_descendants("fft")
    valid_keys.add("fft")
    for key in valid_keys:
        children[key].intersection_update(valid_keys)
        if key in parents:
            parents[key].intersection_update(valid_keys)

    fftpaths = paths['fft']
    
    to_visit = set()
    to_visit.add('fft')
    paths = defaultdict(int)
    paths['fft'] = fftpaths
    visited = set()


    while 'dac' not in visited:
        curr = to_visit.pop()
        if curr in visited:
            continue
        visited.add(curr)
        for child in children[curr]:
            paths[child] += paths[curr]
            if child not in visited and parents[child] <= visited:
                to_visit.add(child)

    valid_keys = get_descendants("dac")
    valid_keys.add("dac")
    for key in valid_keys:
        children[key].intersection_update(valid_keys)
        if key in parents:
            parents[key].intersection_update(valid_keys)

    
    dacpaths = (paths['dac'])

    to_visit = set()
    to_visit.add('dac')
    paths = defaultdict(int)
    paths['dac'] = dacpaths
    visited = set()

    while 'out' not in visited:
        curr = to_visit.pop()
        if curr in visited:
            continue
        visited.add(curr)
        for child in children[curr]:
            paths[child] += paths[curr]
            if child not in visited and parents[child] <= visited:
                to_visit.add(child)
    ans = paths['out']
    print(ans)
    puzzle.answer_b = ans
part_a()
part_b()
```