# Advent of Code 2025 Day 10

## Part A

The only issue I had with A is finding an efficient way to find all powersets. Fortunately, using `chain` and `combinations` from `itertools` gave all subsets of rules in increasing cardinality, so all I had to do was break when the symmetric differences of all the rules in the subset was equal to the locations that should be on.  

## Part B

I tried memoization like [2023 Day 12](/2023/notes/12.md), but it was running sooooo sloooow.

That took me over an hour of writing, debugging, and verifying just to see it run so slow.

Tried optimizing, optimizing was still slow. 

Gave up on that, did integer linear programming. 

Suppose we had $n$ machines and $k$ buttons. Let $A\in\mathbb Z^{n\times k}$. We define $a_{ij}$ to be 1 if button $j$ toggles machine $i$ and 0 otherwise. Then let $b\in \mathbb Z^n$, where $b_i$ is the joltage of machine $i$. Then our solution is the $x\in \mathbb Z ^k$ with $Ax=b$ and $x_i \geq 0$ that minimizes $\sum x_i$. 

Wrote that in five minutes.

I'm a little mad.

## Code

```python
from aocd.models import Puzzle
import itertools as it
from scipy.optimize import linprog

puzzle = Puzzle(year = 2025, day = 10)

data = puzzle.input_data
# data = puzzle.examples[0].input_data

def powerset(iterable):
    s = iterable
    return it.chain.from_iterable(it.combinations(s,r) for r in range(len(s)+1))

def part_a():
    total = 0
    for line in data.split('\n'):
        targetStr = line.split(' ')[0][1:-1]
        target = set(i for i,chr in enumerate(targetStr) if chr == '#')
        rules = line.split(' ')[1:-1]
        rules = list(set(int(i) for i in rule[1:-1].split(',')) for rule in rules)
        for ruleSubset in powerset(rules):
            current = set()
            for rule in ruleSubset:
                current.symmetric_difference_update(rule)
            if target == current:
                total += len(ruleSubset)
                break
    print(total)
    puzzle.answer_a = total

def part_b():
    total = 0
    for line in data.split('\n'):
        targetStr = line.split(' ')[-1][1:-1]
        targetCounts = list(int(v) for v in targetStr.split(','))
        rules = line.split(' ')[1:-1]
        rules = list(set(int(i) for i in rule[1:-1].split(',')) for rule in rules)
        ones = [1] * len(rules)
        A = []
        for i in range(len(targetCounts)):
            A.append(list((1 if i in s else 0) for s in rules))
        solution = linprog(A_eq=A, b_eq = targetCounts, c = ones, integrality=1)
        total += int(solution.fun)
    print(total)
    puzzle.answer_b = total

part_a()
part_b()
```
