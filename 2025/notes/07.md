# AOC 2025 Day 7

Actually programming out of my mind right now. Reminded me a lot of [2024 Day 19](/2024/notes/19.md).

## Part A

First, parsing the data. I created a dictionary whose keys were the line number and values the set of positions where there is a manifold. That way, I was looking into a set each time I wanted to determine if there was a split.

Then, counting the number of beams means for each line and for each previous beam, if there was a splitter at that point, add 2 new beams and increase the number of splits. Otherwise, just add that beam back.

## Part B

Just a quick modification. Instead of using a set to determine the location of beams, use a dictionary whose keys are the beam indicies and values the number of timelines we can reach that location.

Then, if no split, the value stays the same. Otherwise, increase the adjacent values by the number of timelines to reach that location.

## Code

```python
from aocd.models import Puzzle
from collections import defaultdict

puzzle = Puzzle(year = 2025, day = 7)

data = puzzle.input_data

def part_a():
    sx = -1
    manifolds = defaultdict(set)
    for y,line in enumerate(data.split('\n')):
        for x,chr in enumerate(line):
            if chr == "S":
                sx = x
            elif chr == '^':
                manifolds[y].add(x)
    beams = set()
    beams.add(sx)
    splits = 0
    for y,line in enumerate(data.split('\n')[1:],1):
        newBeams = set()
        for beam in beams:
            if beam in manifolds[y]:
                newBeams.add(beam-1)
                newBeams.add(beam+1)
                splits += 1
            else:
                newBeams.add(beam)
        beams = newBeams.copy()
    print(splits)
    puzzle.answer_a = splits

def part_b():
    sx = -1
    manifolds = defaultdict(set)
    for y,line in enumerate(data.split('\n')):
        for x,chr in enumerate(line):
            if chr == "S":
                sx = x
            elif chr == '^':
                manifolds[y].add(x)
    beams = defaultdict(int)
    beams[sx] = 1
    splits = 0
    for y,line in enumerate(data.split('\n')[1:],1):
        newBeams = defaultdict(int)
        for beam, count in beams.items():
            if beam in manifolds[y]:
                newBeams[beam+1] += count
                newBeams[beam-1] += count
            else:
                newBeams[beam] += count
        beams = newBeams.copy()
    print(sum(beams.values()))
    puzzle.answer_b = sum(beams.values())

part_a()
part_b()
```