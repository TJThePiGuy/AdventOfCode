# AOC 2025 Day 2

## Part A

Not too bad. First instinct: brute force. I initially was running into issues with `L` being a float, just had to int divide.

## Part B

Also not too bad. Checked every possible length `l` of substring that could be the "repeated" string, which ended up just being the divisors of the length of the number. Then I put all substrings of size `l` into a set and checked its length.

## Code

```python
from aocd.models import Puzzle

puzzle = Puzzle(year = 2025, day = 2)

data = puzzle.input_data
# data = '''11-22,95-115,998-1012,1188511880-1188511890,222220-222224,
# 1698522-1698528,446443-446449,38593856-38593862,565653-565659,
# 824824821-824824827,2121212118-2121212124'''

def part_a():
    count = 0
    for pair in data.split(','):
        i = int(pair.split('-')[0])
        j = int(pair.split('-')[1])

        for num in range(int(i),int(j)+1):
            L = len(str(num))
            if L % 2 == 1:
                continue
            if str(num)[0:(L//2)] == str(num)[L//2:]:
                count += num
    print(count)

    puzzle.answer_a = count
    # print(data)

def part_b():
    count = 0
    for pair in data.split(','):
        i = int(pair.split('-')[0])
        j = int(pair.split('-')[1])
        # valid = set()

        for num in (range(int(i),int(j)+1)):
            S = str(num)
            L = len(S)
            flag = False
            for sublen in range(1, L//2 + 1):
                if L % sublen != 0:
                    continue
                digit_set = set(S[start:start+sublen] for start in range(0, L, sublen))

                if len(digit_set) == 1:
                    flag = True
                    break
            if flag:
                count += num
                # valid.add(num)
        # print(i, j, valid)
    print(count)

    puzzle.answer_b = count
    # print(data)


part_a()
part_b()
```